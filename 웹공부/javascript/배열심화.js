// // 원시형 데이터 타입은 값을 가져오지만, 객체형 데이터 타입은 주소로 참조
// let arr1 =[1,2,3,4,5];
// let arr2 = arr1;

// arr2[3] = 33333;
// console.log(arr2);//arr2를 호출하는 것은 arr1을 호출하는것과 같음, 서로 변수의 이름만 다르지  값은 같음.
// console.log(arr1);
// // 얕은 복사 복사한척만 하는 것
// // 깊은 복사 데이터를 그대로 복제하는 것
// // 1. 해당배열의 모든 요소를 순회하면서 차곡차곡 넣음
// // 2. splice 함수 사 : 함수 이름은 같은데 매개변수가 다르면 다른함수처럼 작동하는 것 = 오버로드
// //    배열1 = 배열2.splice();
// // 3. ...으로 배열의 모든 원소 가져오기 ... 넣기 : arr2 = [...arr1] 
// // 4. concat 함수 사용 : concatenate// 사슬같이잇다 : 문자열2.concat(문자열1)/ 배열1.concat(배열2)

// //push
// arr1.push(70,100); // 배열의 맨뒤에 요소를 추가함
// console.log(arr1);

// //unshift : 맨앞에 추가되어 배열의 순서가 다 바뀌어지므로 진행 속도가 느림.
// //pop : 제일 뒤에 요소를 제거
// arr1.pop();
// console.log(arr1);
// //shift : 제일 앞의 요소를 제거하여 배열순서가 다 바뀌어 진행속도가 느림
// //join : 사잇글자로 모든 요소를 합쳐주고 그 사이에 넣어줌
// let joinStr = arr1.join('|');
// console.log(joinStr);
// //sort : 문자열 abcd의1,2,3,4 기준으로 배열의 요소를 적절한 위치에 정렬한 후 출력함.
// // 숫자열의 경우 1,2,3,4로 정렬하는데 11이 2보다 앞으로 오는 이유는 앞에 시작되는 수가 1이기 때문
// arr1.sort();
// console.log(arr1);

// arr1.sort(function(a,b){//오름차순
//     return a-b;// a가 클때 양수가 반환된다. 근데  sort가 함수를 만든 사람이 콜백함수가 양수를 반환하면 오름차순으로 정렬하게 만듬
//     }
// );
// console.log('숫자 sort 이후 : ' +arr1);

// present(배열, 발표자번호) 함수를 호출
// 1반의 학생 5명
// 2반의 학생 6명
// 3반의 학생 3명 배열 만들어놓고
// 해당반의 해당번호의 학생에게 발표시키기
// function present(반,번호){
//     console.log(`${반[번호-1]}학생 발표하세요`);
// }
// let 반1 = ['김선형','김형선','차형주','서선호','채제영'];
// let 반2 = ['형선김','선형김','문호준','오세영','정상필','배성원'];
// let 반3 = ['선김형','형김선', '이용수'];
// present(반3,7);
